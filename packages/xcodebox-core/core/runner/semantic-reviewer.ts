import { readFileSync, readdirSync, statSync } from "node:fs";
import { resolve, join, extname } from "node:path";
import { execSync } from "node:child_process";
type Severity = "info"|"warn"|"error";
type Finding = { severity: Severity; message: string; file?: string; line?: number };
export type SemanticReviewResult = { score: number; findings: Finding[]; model?: string; analyzedFiles: string[]; };
const FILE_EXTS = new Set([".ts",".tsx",".js",".jsx"]);
function listFiles(dir: string): string[] { const out:string[]=[]; const stack=[dir]; while(stack.length){ const d=stack.pop()!; for(const name of readdirSync(d)){ if(name==="node_modules"||name.startsWith(".")) continue; const p=join(d,name); const st=statSync(p); if(st.isDirectory()) stack.push(p); else if(FILE_EXTS.has(extname(p))) out.push(p);} } return out;}
function getChangedFiles(): string[]{ try{ const base=process.env.GITHUB_BASE_REF||process.env.XCODE_DIFF_BASE||"origin/main"; const cmd=`git fetch --depth=1 ${base} || true; git diff --name-only ${base}...HEAD`; const out=execSync(cmd,{encoding:"utf-8"}); return out.split("\n").map(s=>s.trim()).filter(f=>FILE_EXTS.has(extname(f))); }catch{return[];}}
function heuristic(files:string[]){ const findings:Finding[]=[]; let pen=0; for(const f of files){ let text=""; try{ text=readFileSync(f,"utf-8"); }catch{ continue; } if(/app\.(get|post|put|patch|delete)\(/.test(text) && /prisma\./.test(text)){ findings.push({severity:"warn",message:"Route handler uses Prisma directly; move to service layer.",file:f}); pen+=0.12; } if(/: any\b/.test(text)){ findings.push({severity:"info",message:"Avoid 'any' in types.",file:f}); pen+=0.03;} if(/try\s*{[\s\S]*}\s*catch\s*\(\s*\w*\s*\)\s*{?\s*}\s*/.test(text)){ findings.push({severity:"warn",message:"Empty catch; log/handle error.",file:f}); pen+=0.06;} if(/eval\s*\(/.test(text)){ findings.push({severity:"error",message:"Avoid eval; unsafe.",file:f}); pen+=0.25;} } const base=Math.max(0,Math.min(1,0.97-pen)); return { findings, baseScore: base }; }
function scoreMix(base:number, findings:Finding[]):number{ const w={error:0.25,warn:0.1,info:0.03} as Record<Severity,number>; const pen=findings.reduce((s,f)=>s+(w[f.severity]||0),0); return Math.max(0,Math.min(1, base - pen)); }
export async function semanticReview(root=process.cwd()){ let targets=getChangedFiles().filter(f=>f.startsWith("src/")); if(!targets.length){ const dirs=["services","routes","providers","lib"].map(d=>resolve(root,"src",d)).filter(p=>{ try{ return statSync(p).isDirectory(); }catch{return false;}}); targets=dirs.flatMap(d=>listFiles(d)); } const h=heuristic(targets); const findings=[...h.findings]; const score=scoreMix(h.baseScore, findings); return { score, findings, analyzedFiles: targets, model:"heuristic-diff-aware" }; }
